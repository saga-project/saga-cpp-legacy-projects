%\documentclass[3p,twocolumn]{article}
\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{color}
\usepackage{url}
\usepackage{ifpdf}
\usepackage{hyperref}
\usepackage{xspace}

\setlength\parskip{-0.015em}
\setlength\parsep{-0.15em}

\newenvironment{shortlist}{
	\vspace*{-0.85em}
  \begin{itemize}
 \setlength{\itemsep}{-0.3em}
}{
  \end{itemize}
	\vspace*{-0.6em}
}

\usepackage{fullpage}
%\usepackage[top=tlength, bottom=blength, left=llength, right=rlength]{geometry} %http://en.wikibooks.org/wiki/LaTeX/Page_Layout
%\usepackage[margin=1in, paperwidth=5.5in, paperheight=8.5in]{geometry}

\usepackage{fancyhdr}
\setlength{\headheight}{16.0pt}
\pagestyle{fancy}
\headheight = 0pt
\headsep    = 25pt
\fancyhf{}
\fancyhead[OC]{\bf {\it \footnotesize{Jha et al: A Case for SAGA as an Access Layer for DCI}}}

\newif\ifdraft
\drafttrue
\ifdraft
 \newcommand{\amnote}[1]{  {\textcolor{magenta} {***AM: #1}}}
 \newcommand{\jhanote}[1]{ {\textcolor{red}     {***SJ: #1}}}
 \newcommand{\olenote}[1]{ {\textcolor{blue}    {***OW: #1}}}
\else
 \newcommand{\amnote}[1]{}
 \newcommand{\jhanote}[1]{}
 \newcommand{\olenote}[1]{}
\fi

\newcommand{\dn}{\vspace*{0.33em}}
\newcommand{\dnn}{\vspace*{0.66em}}
\newcommand{\dnnn}{\vspace*{1em}}
\newcommand{\uppp}{\vspace*{-1em}}
\newcommand{\upp}{\vspace*{-0.66em}}
\newcommand{\up}{\vspace*{-0.33em}}
\newcommand{\shift}{\hspace*{1.00em}}

\newcommand{\T}[1]{\texttt{#1}}
\newcommand{\I}[1]{\textit{#1}}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\BI}[1]{\B{\I{#1}}}
\newcommand{\F}[1]{\B{[FIXME: #1]}}
\newcommand{\TODO}[1]{\textcolor{red}{\B{TODO: #1}}}



\begin{document}

\title{Whitepaper: A Case for SAGA as Access Layer for Production
  Distributed Computing Infrastructures}

\author{Shantenu Jha$^{*1,2}$, Andre Merzky$^{1}$, Ole Weidner$^{1}$\\
  \small{\emph{$^{1}$Center for Computation \& Technology, Louisiana State University, USA}}\\
  \small{\emph{$^{2}$Department of Computer Science, Louisiana State University, USA}}\\
  \small{\emph{$^{*}$Contact Author \texttt{sjha@cct.lsu.edu}}}
  }


\maketitle

\section*{Abstract}

 This is currently an abstract Abstract

 The aim of this document is to inform designers, architects and users
 of production level distributed Computing infrastructures of the role
 the SAGA API can play as an end user access layer.

\section{Introduction}

 The "Simple API for Grid Applications"  is, as the name suggests, a
 simple API which allows to implement distributed applications.  It
 originally focused on Grid applications (i.e. applications running
 in Grid environments), but in fact maps well to all kinds of
 distributed infrastructures.

 SAGA was designed with 3 main goals:

 \begin{enumerate}

  \item provide a stable programming interface to application
  programmers
 
  \item allow to simply express distributed application properties,
  by providing high level abstraction of distributed and remote
  operations
  
  \item shield the application developer from heterogeneous and
  evolving infrastructures and middlewares

 \end{enumerate}

 The fact that SAGA is an OGF standard ensures the stability of the
 API.   SAGA's scope is defined top-down, i.e. is determined by the
 high-level (i,e, application level) requirements.  And SAGA's main
 design principle is the 80:20 rule: 80\% of functionality at 20\% of
 the complexity.


\section{The SAGA Landscape}

 \subsection{SAGA API Specification}

  The SAGA API specification process is hosted by the Open Grid Forum
  (http://www.ogf.org/).  The SAGA Working group within OGFs
  application area first collected a set of ca. 20 use cases,
  considered representative for a wide range of distributed scientific
  applications.  Based on these use cases, the group defined a set if
  high level abstractions commonly required by those use cases.  Those
  abstractions were then mapped into different SAGA API packages,
  while ensuring that (a) the overall usability (e.g. the API
  look-and-feel) was consistent over the whole scope of the API, (b)
  the API functionality maps relatively well (but not necessarily
  simply) onto existing middleware features, and (c) the API stayed
  simple to use.

  The fact that the resulting SAGA API specification is a rather hefty
  document is not a token of the complexity of the resulting API, but
  rather a token for the level of detail the API semantics is
  specified.  Also, it must be noted while the resulting API is indeed
  rather simple to use, it is, to most parts, rather difficult to {\bf
  implement} - ease of implementation has {\it not} been a design goal
  for SAGA.  Modern distributed computing environments are very
  complex infrastructures, and allowing applications to make use of
  these complex systems is not trivial.  By defining a simple API, one
  requires those complexities to be dealt with on a different layer,
  i.e. within the SAGA API implementation. This is on purpose, as it
  allows to keep those complexities out of the application code, which
  is a declared goal of SAGA.

  The SAGA API specification is object oriented, and language
  independent (the API is defined in IDL).  The API is structured into
  various packages (e.g. jobs, replicas, streams, etc.).  Those
  packages have limited dependencies amongst each other - not all SAGA
  implementations implement all packages.  All API packages share
  certain properties: how are synchronous methods expressed, how are
  notifications realized, how are security tokens expressed, what
  types of exceptions are defined, etc.  Those properties are
  specified in the SAGA-Core, the API's look and feel.  

  That design of the SAGA API allows to specify additional API
  packages, which adhere to the same look-and-feel.  In fact, several
  such API packages have already been defined, and are standardized as
  well, or are in the process of being standardized.

  \jhanote{Andre to put in a few sentences about SAGA and other OGF
    Efforts, e.g., GIN/PGI -- how they cross fertilize and enable ...}

  \jhanote{SJ to shorten a bit..}

  \subsection{SAGA Core: Implementation and Deployment}

  \subsubsection{SAGA Implementations}

  The language independent SAGA API specification has been mapped to
  multiple programming languages, in particular to C++, Java and
  Python.  Multiple implementations exists, the most notable ones are
  SAGA-C++, JSAGA and JavaSAGA.

  SAGA-C++ is...

  JSAGA and JavaSAGA are …

  All three implementations provide python bindings - the Java
  implementations realize those via Jython, the C++-implementation via
  boost-python.  The two python bindings are at the moment being
  unified, and have already been shown to be interoperable.

  Interestingly, all three discussed SAGA implementations are adaptor
  based: they implement a relatively small library which provides the
  SAGA API, and a set of adaptors which translate the SAGA API calls
  into the respective middleware operations.  It is those adaptors
  which encapsulate most of the complexity which was formerly present
  in the applications layer.  While SAGA adaptors are relatively easy
  to implement, at least as a prototype, they require significant
  maintainance effort to keep up with the middleare intricacies and
  evolution.

 \subsection{SAGA Components}

<<<<<<< .mine
  While SAGA is foremost an API, the SAGA distributions support end
  users in a variety of ways.  In particular, the SAGA distributions
  also include command line tools implemented via the SAGA API, and
  higher level libraries for common distributed programming patterns,
  also basing on the SAGA API.  Further, the SAGA distributions
  provides comprehensive support to compile, link and run SAGA
  applications (configure scripts, make support, runtime wrappers,
  developer tutorials , etc).

  Command line tools are, in our experience, amongst the first
  components of any distributed middleware to be exploited by end
  users.  SAGA-C++ provides a set of command line tools which
  basically cover the complete semantic set of SAGA API calls, such as
  job submission and management, file management, replica management,
  etc.

  Several SAGA based projects are actively developing and using higher
  level programming abstractions, such as pilotjobs, bigjobs,
  mapreduce, or workflows.  Such components are routinely installed
  and used by a number of user communities, and represent significant
  added avlue, although they are not part of the SAGA core code base.
  It should be noted that the SAGA Python bindings, which are usually
  installed by default, are very frequently used to provide tooling and
  higher level programming abstractions.



 \subsection{Important SAGA Deployments}
=======
  \subsubsection{Important SAGA Deployments}
>>>>>>> .r3388

  The different SAGA implementations, and in particular SAGA-C++, have
  by now been in use in different user communities for a number of
  years, and thus have matured enough to enter the  field of
  production cyber infrastructures.  At the same time, the number of
  supported backends has grown to a level that basically all current
  production infrastructures are supported (e.g. for jobs we support
  ARC, gLite, Globus, Condor, PBS, Torque, DRMAA, EC2, Eucalyptus,
  BES,  Naregi, Unicore, SMOA, Genesis-II, fork, and ssh).  

  SAGA has so far been successfully and routinely used on the
  TeraGrid, LONI, FutureGrid, DEISA, NAREGI/RENEKI and a number of
  smaller, more localized DCI. It has also been used by a range of
  e-Science projects such as EGEE, DGrid, VPH etc.

  SAGA-C++ has one major external dependency, which is
  boost\footnote{\url{http://www.boost.org/}}, a set of C++ headers
  and lbraries widely used in the C++ community.  While boost itself
  is a fairly complex code base, it is routinely packaged by the
  various Unix distributions, and thus usually available out of the
  box.  Further, SAGA-C++ is able to compile against a wide range of
  boost releases, including those which are the default versions for
  the currently used Linux distributions.  Postgresql client libraries
  are not strictly required, but recommended for some of the core SAGA
  functionality.

  While SAGA is relatively easy to deploy in applications space (i.e.
  user space), its overall goal of improving the end user experience
  of distributed systems benefits greatly from system level
  installations.  It is straight forward to install SAGA in user space
  (\T{configure; make; make install}), but in our experience, the
  correct environment setup to use a SAGA installation in user space
  is still a stumbling stone for many end users (\T{LD\_LIBRARY\_PATH}
  etc).  We thus prefer SAGA to be available in system space, which
  lowers the entry barrier significantly.  

  We are currently working to provide binary releases, in the form of
  Debian and Ubuntu packages, and RPMs.  Also, we are currently
  integrating SAGA into NMI and ETICS build and testing environments,
  which we hope will lower the effort for system level installations
  significantly.


  \subsection{SAGA Adaptors: Implementation and Deployment}

 For a list of adaptors that are currently supported, refer to:
 \url{http://saga.cct.lsu.edu/software/cpp}

 \subsection{SAGA usage modes}

 Although SAGA is foremost an API, the SAGA distributions support end
 users in a variety of ways.  In particular, the SAGA distributions
 also include command line tools implemented via the SAGA API, and
 higher level libraries for common distributed programming patterns,
 also basing on the SAGA API.


\section{SAGA Usage and Active Projects}

\subsection{SAGA Active Projects}

 \subsubsection{Standards promote Interoperability}

 \subsubsection*{ExTENCI}

  ExTENCI: TeraGrid-OSG (2010-12)

  Cactus Application Scenarios
 
  \begin{itemize}  

   \item  Problem size varies – determinant of Infrastructure used
          \begin{itemize}
           \item TG, OSG or either...
          \end{itemize}
 
   \item  MPI-based applications have a very complex SW environment
          that they need to worry about
 
   \item  Application Scenarios/Usage Modes
          \begin{itemize}
           \item Ensemble of Cactus Simulations (NumRel, EnKF
                 (Petroleum Eng))
           \item Multiphysics Code (GR-MHD, CFD-MD)
           \item Spawning Simulations (Realtime ‘outsourcing’ from
                 BlueWaters/Ranger to specialised architectures or 
                 less powerful resources)
          \end{itemize}
 
  \end{itemize}

\subsubsection*{DEISA/TG/interop VPH (under virt phys human), pilotjob
                  (mult ensembles of 16/32 way par jobs)}
 \subsubsection*{gLite / Ganga} glite+globus/CERN/HEP /
 \subsubsection*{RENKEI/NAREGI}

\subsubsection{Applications Scenarios}
\subsubsection*{Cybertools} 
\subsubsection*{Mapper: multiphysics,}
\subsubsection*{NeuGrid / UWE} medical imaging, workflow

\subsubsection{Tooling}
   \subsubsection*{JSAGA, Service Discovery}
   \subsubsection*{SAGA-based Pilot Jobs (BigJobs)}
   \subsubsection*{Computational Biology Gateways}

\section{Analysis of Use Cases}

SAGA is used for multiple reasons. Three primary usage modes of SAGA
are the following: (i) Simplifying access layer, (ii) building block
for tools and distributed execution execution, and (iii) a distributed
scripting and programming capability.

Distributed Computing is more than just submitting isolated jobs.

It is about federating resources dynamically; about coordinated
execution of heteregeneous and dynamic workloads; it is about
distributed data management etc..


A primary objective of SAGA is to support and simplify the
implementation of distributed applications.  As described earlier,
that is achieved by providing a library which implements the SAGA API.
However, distributed applications have to {\it wrestle} with
distributed infrastructures at more layers than just APIs, and the
SAGA distribution tries to address a number of additional issues as
well. In particular prototyping, deployment, and application
enrollment and bootstrapping are continous concerns for end users.

  \subsubsection*{Application Prototyping and Tooling}

   The SAGA python bindings have been proven to be immensely helpful
   for application prototyping.  But also, they are very helpful when
   interactively testing remote operations (in the interactive python
   interpreter / python shell).  Finally, it is very easy to implement
   small command line tools in python, which are able to mimic and
   test smaller portions of the overall application.  For example, it
   is straight forward to implement a specific job control component
   of an application in a stand alone python script, and to later
   include the same functionality in the application proper, with the
   confidence that the semantics of the remote operations will be well
   preserved. %(remember: the SAGA specification is very strict about
   %the definition of semantics).


  \subsubsection*{Application Development}

%    According to the SAGA use case analysis\cite{saga-uc}, and to our
%    own experience in developing distributed applications, the set of
%    funtionality required for such applications is rather limited.
%    However, as that functionality is provided in very different ways,
%    by the various distributed middlewares available today, application
%    complexity has historically increased significantly for any single
%    remote operation used by the application.

  The SAGA API provides very concise and high level method calls which
  cover the vaste majority of distributed operations, as required by
  the target user community -- scientific application and tool
  developers.  Further, as the API specification and implementation is
  \I{standardized}, and thus stable, it allows for a 'write once, run
  anywhere' approach, which is in general not available otherwise (or
  at least not without \I{significantly} increase of application
  complexity).

 \subsubsection*{Application Deployment}

 \subsubsection*{Runtime Configuration}

   


\section{Relevance to EGI/UMD}

Access Layer to EMI - ARC, gLite and Unicore, while working well with
Globus (IGE). In fact first few success stories of IGE are built
around applications that use SAGA.

Distributed Scripting/programmatic access

Interoperability with OSG (and TeraGrid-XD).

\section{SAGA as a Standardized Programmatic and Access Layer:
  Advantage to DCI Providers}

As part of the ExTENCI project, SAGA will make major advances towards
becoming a broadly usable programmatic access layer to Condor/OSG.
For example the Structural Biology Grid that currently
(\url{http://SBGrid.org}) currently implements sophisticated analysis
and user-defined pipelines. However, these are inherently localized
and confined to specific infrastructure.  Replacing ``local python''
calls with ``distributed (SAGA) python'' calls enables the seamless
utilization of DCI. This provides a simple mode of extensibililty of
infrastructure, without any major refactoring of code. The advantages
of this to the end-user is obvious; the lowered barrier-to-entry for
novel users and communities will increase the ease and uptake of DCI
thus benefitting DCI providers/organizations.

\section{SAGA Future/Roadmap}

\bibliographystyle{plain}
\bibliography{egi-white-paper}

\end{document}

