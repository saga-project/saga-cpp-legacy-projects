\documentclass[]{article}

% Use utf-8 encoding for foreign characters
\usepackage[utf8]{inputenc}

% Setup for fullpage use
\usepackage{fullpage}

% Uncomment some of the following if you use the features
%
% Running Headers and footers
%\usepackage{fancyhdr}

% Multipart figures
%\usepackage{subfigure}

% More symbols
%\usepackage{amsmath}
%\usepackage{amssymb}
%\usepackage{latexsym}

% Surround parts of graphics with box
\usepackage{boxedminipage}

% Package for including code in the document
\usepackage{listings}

% If you want to generate a toc for each chapter (use with book)
\usepackage{minitoc}

% This is now the recommended way for checking for PDFLaTeX:
\usepackage{ifpdf}

\usepackage{url}

%\newif\ifpdf
%\ifx\pdfoutput\undefined
%\pdffalse % we are not running PDFLaTeX
%\else
%\pdfoutput=1 % we are running PDFLaTeX
%\pdftrue
%\fi

\ifpdf
\usepackage[pdftex]{graphicx}
\else
\usepackage{graphicx}
\fi

\usepackage{color}
\definecolor{listinggray}{gray}{0.95}
\definecolor{darkgray}{gray}{0.7}
\definecolor{commentgreen}{rgb}{0, 0.4, 0}
\definecolor{darkblue}{rgb}{0, 0, 0.4}
\definecolor{middleblue}{rgb}{0, 0, 0.7}
\definecolor{darkred}{rgb}{0.4, 0, 0}
\definecolor{brown}{rgb}{0.5, 0.5, 0}

\newif\ifdraft
\drafttrue
\ifdraft
\newcommand{\jhanote}[1]{ {\textcolor{red} { ***shantenu: #1 }}}
\newcommand{\alnote}[1]{ {\textcolor{blue} { ***andre: #1 }}}
\newcommand{\smnote}[1]{ {\textcolor{green} { ***sharath: #1 }}}
\newcommand{\msnote}[1]{ {\textcolor{cyan} { ***mark: #1 }}}
\else
\newcommand{\alnote}[1]{}
\newcommand{\athotanote}[1]{}
\newcommand{\smnote}[1]{}
\fi




\title{BigJob, ManyJob, Pilot-Store, ... -- Abstractions for dynamic ...}
\author{  }

\date{2011-04-26}





\begin{document}

\ifpdf
\DeclareGraphicsExtensions{.pdf, .jpg, .tif}
\else
\DeclareGraphicsExtensions{.eps, .jpg}
\fi

\maketitle


\section{Pilot-Jobs}

The uptake of distributed infrastructures by scientific applications has been
limited by the availability of extensible, pervasive and simple-to-use
abstractions which are required at multiple levels – development, deployment
and execution stages of scientific applications. The Pilot-Job abstraction has
been shown to be an effective abstraction to address many requirements of
scientific applications. Specifically, Pilot-Jobs support the decoupling of
workload submission from resource assignment; this results in a flexible
execution model, which in turn enables the distributed scale-out of
applications on multiple and possibly heterogeneous resources. Most Pilot-Job
implementations however, are tied to a specific infrastructure. In this paper,
we describe the design and implementation of a SAGA-based Pilot-Job, which
supports a wide range of application types, and is usable over a broad range
of infrastructures, i.e., it is general-purpose and extensible, and as we will
argue is also interoperable with Clouds.

\msnote{regarding SAGA-based, is it really SAGA based, or rather an 
extension?}\alnote{The implementation utilizes SAGA, but it is not a really a 
SAGA extension yet - there is not even a draft for a spec extension yet}

\msnote{why the explicit mentioning of clouds while in the same sentence there is referred to a "broad range of infrastructures"}

\subsection{Motivation}

Distributed systems are inherently dynamic: resources can suddenly fail or 
new resources can become available at any time. Generally there are two types
of dynamism.
\begin{itemize}
    \item \textbf{Resource dynamism:} Distributed systems are inherently dynamic
     -- resources can become available or fail at any time. The same holds for
      network connections.
	\item \textbf{Application dynamism} describes the requirement of many
applications to support dynamic resource requirements. An example are
applications whose execution time resource requirements cannot be determined
exactly in advance (either due to changes in runtime requirements) or those that
are dependent on dynamic data (e. g. sensor, in-transit or variable source/sink
of data).
\end{itemize}

Further things to consider:
\begin{itemize}
    \item dynamic scheduling
    \item dynamic task placement
    \item autonomic behaviors: Monitoring of the system/application state and 
    adaptations of the application and/or resources to respond to changing 
    requirements or environment.
\end{itemize}

The real power of distributed systems, however, arises from adaptive algorithms
and implementations that provide applications with an agile execution model, and
thus the ability to use resources dynamically as opposed to a static execution
model inherited from parallel and cluster computing

\msnote{What paper is this referring to? I disagree btw, the real power does not arise from adaptive algorithms and implementations, instead, the power can only be fully exploited by using those.}\alnote{\url{http://www.cct.lsu.edu/~sjha/select_publications/adaptive_repex_ptrsa.pdf}}

\subsection{Definitions}

\begin{itemize}
	\item Pilot-Job
	\item Sub-Job
	\msnote{I'm not that fond of the "sub-job", is it a task?}
	\item Placeholder-Job
	\item Resource-Agent
\end{itemize}


Related terms:
\begin{itemize}
	\item opportunistic resource usage
\end{itemize}

\subsection{Characteristics:}
\begin{itemize}
	\item \textbf{Task binding:~\cite{diane-thesis}} 
		\begin{itemize}
			\item In the traditional early binding approach a job carries
			 exactly one task which is specified at a time of job submission.
			\item Late binding is a scheduling and coordination
			 method, where work is assigned to a job at runtime rather than at
			 submission time.
			\begin{itemize}
				\item At sub-job submission 
				\item After sub-job submission
			\end{itemize}
		\end{itemize} 	

	\item \textbf{Resource Types:}
	\begin{itemize}
		\item Cluster support, i.e. Number of resources per BigJob
		\item Number of concurrent sub-jobs per BigJob agent
	\end{itemize}
	\item \textbf{Coordination} describes how the various components of 
	the Pilot-Job framework are	coordinated. Possible values for this vector include data
	flow, control flow, SPMD (where the control flow is implicit in all copies of the single program), master-worker
	(the work done by the workers is controlled by the master),
	\begin{itemize}
		\item The data flow describes the flow of messages between the components of the framework, e.\,g.\ point-to-point messaging or publish-subscribe (see Communication).
		\item The control flow describes how the various components of the
		 framework are managed. In the context of pilot-jobs this particularly means how the resource on which a sub-job is executed is determined. Generally, it can be differentiated between the two kinds of decision makings:
			\begin{itemize}
				\item Central: Decisions are centrally made by a master
				 process, i.\,e.\ a central manager decides which sub-job is
				 executed on what resource.
				\item Decentral: Control is distributed among the 
				different components. Pilot-Jobs with decentralized decision 
				making often utilize agents that accepts respectively pull 
				sub-jobs according to a set of defined criteria.
			\end{itemize}
			
			\begin{tabular}{|l|c|c|}
				\hline
				&central &decentral\\
				\hline
			Simplicity  &++			&o \\ \hline
			Decision Quality &+ 	&++ \\ \hline
			Flexibility &+			&++ \\ \hline
			Adaptivity  &+ 			&++ \\ \hline
			Failure Resilience &+   &++\\ \hline
			
			\end{tabular}
		% \item Sub-Job pull vs. push applies to control and data flow (different objects that are pushed/pulled)

	\end{itemize}	
	\item \textbf{Communication:} Data can be exchanged by messages
(point-to-point, all-to-all, one-to-all, all-to-one, or group-to-group),
stream (potentially unicast or multicast), publish/subscribe or through shared
data.
	\begin{itemize}
		\item Remote procedure calls: CORBA, RMI
		\item Messaging: point-to-point, collective operations
		\item Shared data space (e.\,g.\ tuple space): BigJob e.g. uses the Advert service to share data between the manager and the agent (such as task information). In general, this is associated with a push/pull coordination schema, i.e. the manager pushes something to the shared data space and the agents periodically check for new data.
	\end{itemize} 
	\item \textbf{Dynamic Resources:}
		\begin{itemize}
			\item Push/Pull model for growing/shrinking resources
			\item How is this decision made?
		\end{itemize}
	\item \textbf{Data management:} Managing input and output files can be critical in particular with the current increase of data volumes. Pilot-Jobs can support different kinds of data management, e.\,g.\ file stage-in and out. Also, it can provide integration with other kinds of data systems.
	\item \textbf{Fault tolerance:} Large, distributed Grids are highly dynamic and inherently prone to failures and thus unreliable. To deal with failures, systems can deploy strategies, such as automatic resubmission etc.
	\item \textbf{Resource abstraction:} SAGA vs. GANGA
	\msnote{Whats this comparison aiming at?} \alnote{This is not a really 
	defining characteristic. But, since we are talking about abstractions, I 
	thought it might be useful to describe how resources are accessed.}
	\item \textbf{End-user abstraction:} BigJob API
	\item Task scheduling and prioritization
	\begin{itemize}
	 			\item Policies and Algorithms
	 			\item What attributes are required?
	 			\item Multi-level scheduling
	 			\item Integration of data- and compute scheduling
	 			\item see MLS paper
	\end{itemize}
	
	\item Supported middleware types and infrastructures	
	\item Security
\end{itemize}

\alnote{Comments from call (24/04/2011):
\begin{itemize}
	\item Decision on the resources where the BigJob is submitted to
	\item HTC it is quite common that you no knowledge about resources
	\item push/pull for task not for agent
	\item ManyJob: agent being pushed, task being pulled (agent notify master when active)
	\item Marc: Data intensive also become more memory intensive - decoupling of core and worker needed
	\item Further defining task binding: late binding vs. early vs. partial binding	
	\item Sharath: Establish cloud vs. grid BigJob
	\item Affinity does not arise in the static BigJob - should remain just in dynamic
	\item Multiple BigJob instead of ManyJob?
\end{itemize}
Call (27/04/2011)
\begin{itemize}
	\item module for adaptive data, adaptive scheduling    
\end{itemize}
}

\section{PilotJob Implementations}

Table~\ref{tab:pilotjob_overview} gives an overview of different pilot-job
implementations and their characteristics.

\begin{table}[t]
\begin{tabular}{|l|p{2.5cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|}
	\hline
	&\textbf{Task Binding} &\textbf{Cluster Support} &\textbf{Coordina\-tion} & \textbf{Communica\-tion} &\textbf{Dynamic Resources}\\
	\hline
	\textbf{BigJob} & &&&&\\
	\hline
	SAGA BigJob & &&&&\\
	\hline
	\hspace{4mm} Globus/PBS adaptor  &late binding (at sub-job submission)  
									 &yes &central decision making &SAGA Advert (pull/push) &no\\  
	\hline
	\hspace{4mm} Cloud adaptor (EC2) &late binding (at sub-job submission)  
									 &no &central decision making &SAGA Advert (pull/push) &no\\ 
	\hline
 	BigJob-Cloud &late binding (at sub-job submission) &yes &central decision making 
				 &local python-based queue / SAGA Job (SSH adaptor) &no\\ 
	\hline
	BigJob-Azure &late binding (at sub-job submission)
	             &no &central decision making &Azure Storage (push/pull) &no\\ 
	\hline
    BigJob-Diane &late binding  &yes &decentral decision making &CORBA (pull from master) &yes\\ 
	\hline	
	\textbf{Dynamic BigJob} & &&&&\\
	\hline
    ManyJob &late binding (after job submission) &yes &central decision making &SAGA Advert (push/pull) &no\\
	\hline
 	ManyJob-Cloud &late binding (after job submission) &no &central decision making &SAGA Job (SSH) (push) &no\\
	\hline 
	ManyJob-Affinity &late binding (after job submission)
	&yes &central decision making &SAGA Advert (push/pull) &no\\
	\hline
\end{tabular}
\caption{Characteristics of Pilot-Job Implementations According 
		to Defined Vectors} \label{tab:pilotjob_overview}
\end{table}		

		
\vspace{10 mm}

\textbf{Backends}
\begin{itemize}
    \item SAGA/Grid: Globus, PBS, Local, 
    \item EC2-style Clouds (FutureGrid, EC2, Eucalyptus)
    \item Azure
    \item Condor
    \msnote{Glide-In I assume, and not normal condor?}
    \item Diane
\end{itemize}


\textbf{BigJob vs. Diane}

\begin{tabular}{|l|l|l|}
\hline
 &BigJob &Diane\\
\hline
MPI &yes &yes\\
\hline
Advanced Scheduling &no &yes\\
\hline
Dynamic Resources &no &yes\\
\hline
API for Agent Submission &yes &no\\
\hline
\end{tabular}

\msnote{Whats VO in this context?}\alnote{Suppose to describes the capability to dynamically add/remove resource from/to a BigJob}


\subsection{SAGA BigJob}

\begin{figure}[t]
    \centering
        \includegraphics[width=0.7\textwidth]{figures/distributed_pilot_job.pdf}
    \caption{BigJob API and Implementation}
    \label{fig:figures_distributed_pilot_job}
\end{figure}

BigJob comprises of an API (see Figure~\ref{fig:figures_distributed_pilot_job}
and section~\ref{sec:api}) and various resource-specific implementations of the
API. The SAGA-based Pilot-Job is the reference implementation of the BigJob API.
It supports a wide range of application types, and is usable over a broad range
of infrastructures, i.\,e.\ it is general-purpose and extensible.


\subsection{BigJob for Cloud Computing}

BigJob provides support for various cloud computing environment. The SAGA BigJob
implementation can be used in conjunction with the AWS adaptor for SAGA to run
on EC2-based cloud infrastructures, such as FutureGrid. However, there are some 
limitations:...

\textbf{Difference between Bigjob and Bigjob Cloud:} 

\begin{itemize}
	\item ManyJob is required to manage the set of VMs. The BigJob-Cloud can manage a set of VMs without the need of ManyJob.
	\msnote{If BigJob is the atomic unit, it should not differ per backend}
	\item Bigjob uses advert server for communication between BigJob-agent and BigJob whereas BigJob-Cloud does not use an advert server.
	\item Bigjob-cloud does not require SAGA-AWS adaptors as opposed to requirement in original Bigjob. 
\end{itemize}	


\subsection{Dynamic BigJob}

\textbf{SAGA-ManyJob}:
It uses SAGA BigJob approach to start multiple BigJobs agents 
whether on a single resource or on multiple resources. And 
these agents are responsible for pulling the tasks from advert 
service and run the possible subjobs concurrently or in generations.



\textbf{Dynamic BigJob with Affinity Support}:
This implementation is similar to SAGA-ManyJob except that we define affinity for each resource and also define affinity for the tasks. Therefor binding between tasks and resource occur while submitting the jobs.
\msnote{How do we define that affinity?}

This approach is well suited when utilizing wide variety of infrastructure/resources where parameters for the application will change according to the file paths/environment variables etc.. for each resource

\subsection{Extensions}

\subsubsection{Dynamically Resource Management}

To address to the dynamic resource requirements of applications the ability to
dynamically add and remove resources to a BigJob. The proposed API consists of
two parts, the resource management and the resource introspection part:
\begin{itemize}
    \item \texttt{add\_resource()}: New resources are added by starting a new
    big-job.
    \item \texttt{remove\_resource(bigjob)}: Removes the big-job from the
    resources.
\end{itemize}

Higher-level wrappers that encapsulate e.\,g.\ the specific resource
descriptions can be implement. Further, to implement this dynamic resource
capabilities it is necessary to provide different dynamic resource introspection
in the dynamic big-job layer:
\begin{itemize}
    \item \texttt{get\_bigjobs}: returns a list of managed big-job objects. Each
big-job object can be queried for it's allocated resources (number nodes, number
cores).
\end{itemize}


\subsubsection{Dynamic Scheduling}

describe the benefits of de-central decision making 

autonomic capabilities


\subsubsection{Data-/Compute-Affinities}




\section{Pilot Data and Store}

Pilot Data is a set of abstractions for expressing data localities and
affinities. Pilot Data can be used to create groups of file that are always used
together. This concept originates in
Filecules~\cite{Doraimani:2008:FGS:1383422.1383429} Pilot Data provides a set of
basic operations on top of these file groups Pilot Store: A container that
represents a logical group of physical files that share the same affinity.

Pilot Store Containers can be used to express data-data abstractions. 
Abstraction supports basic management tasks (create, delete, update,
move, list). 


\begin{figure}[htbp]
    \centering
        \includegraphics[width=0.8\textwidth]{figures/pilotstore.pdf}
    \caption{Pilot Data and Store Overview}
    \label{fig:figures_pilotstore}
\end{figure}



\subsection{Overview}

The Pilot Data abstraction serves the following needs:
\begin{itemize}
	\item Reservation of physical disk space: acquisition of data storage (advanced reservation, place holder)
	\item Virtual destination: dynamically mapping of data to pilot stores.
	\item Runtime environment for $\alpha$ based data
\end{itemize}

The pilot data abstraction provides two kinds of abstractions (see Figure~\ref{fig:figures_ps-instantiation}):
\begin{itemize}
    \item Pilot Data: Allows the logical grouping of files and the expression of data-data affinities.
    
    \item Pilot Store: Binds a pilot-data object to a actual physical resource. A pilot-store object can function as a placeholder object that reserves the space for a pilot-data object.
\end{itemize}


\begin{figure}[htbp]
    \centering
        \includegraphics[width=0.6\textwidth]{figures/ps-instantiation.pdf}
    \caption{Level of Abstractions - Resource Binding}
    \label{fig:figures_ps-instantiation}
\end{figure}



	
\noindent	
Dynamic data:
\begin{itemize}
	\item Data to be generated (temporal)
	\item Data that is in place (spatial)
	\item Data that is changing (temporal)
	\item Data characteristics, properties
\end{itemize}	

\noindent
Analogies with Pilot-Job:
\begin{itemize}
	\item Assign pilot job to resource: $f^{1}(PJ_i) \rightarrow R_i$
	\item Assign task to pilot-job: $f^{2}(T_i) \rightarrow PJ_i$ 

	\item $g^{1} (D_i) \rightarrow PS_i$
	\item $g^{2} (PS_i) \rightarrow R_i$
\end{itemize}

\subsection{Related Work: BitDew}
\msnote{Interesting, didn't know it, does our group has experience with it?}

Random Notes
\begin{itemize}
	\item Focus on Desktop Grid
	\item Java-based implementation (ie difficult to interface with Python-based PS/SAGA)
	\item highly distributed: stable and volatile nodes
	\item pull model, i.e. a node pulls for new data
\end{itemize}


Mapping to BitDew:
\begin{itemize}
	\item Pilot Store in its current implementation covers Bitdew Data Catalog and Repository
	\item For data management and placement the Active Data API and the Bitdew data scheduler could be used
	\item Transfer Management is done via SAGA File API	
\end{itemize}

How to evolve pilot data/store?
\begin{itemize}
	\item Active management of data (e.g. replication, automatic affinity management) requires an active component:
	\begin{itemize}
		\item Manager/Agent model as in BigJob?
		\item Who runs active components? Started as part of batch job or separate install/start?
	\end{itemize}
\end{itemize}

Questions:
\begin{itemize}
    \item How should
    we store data in order to effectively cope with non-uniform demand for
    data? 
    \item How many copies of popular data objects do we need? 
    \item Where should we store them for effective load balancing?
\end{itemize}

\subsection{TODO/Future Work}
The current framework provides building blocks for expressing data localities and operation on file groups (similar to filecules).

Limitations:
\begin{itemize}
    \item No active agent that monitors state of files
    \item No placement policy support or autonomic behavior
    \item Infrastructures generally expose insufficient locality/topology information
    \item Compute – Data Affinity: Dynamic BigJob with affinity only provides a very coarse-grained affinity
    \item No policy for what’s happening if data is not available in right location:
    \begin{itemize}
        \item Run anyways – affinity is just an hint
    \end{itemize}
    \item When to move pilot stores? Move or copy?
    \item Move data to compute or visa versa?
    \item Data Replication: Identification of the same file: logical filename -> physical files. Manage replication process (consistency!)
\end{itemize}

\section{Pilot-Job and Pilot-Store as Runtime Environment for MR}
...
Scenarios:
\begin{itemize}
	\item 1 BJ 16 core 1 machine
	\item 2 BJ 8 cores - 1 machines
	\item 2 BJ 8 cores - 2 machines
\end{itemize}

other parameters:
\begin{itemize}
	\item placement of data
	\item cloud
\end{itemize}

\section{BFast Scenario for Dynamic Data}

\textbf{Types of Input Files:}
\begin{itemize}
	\item static data: 
	\begin{itemize}
		\item reference genome
		\item index files
	\end{itemize}
	\item dynamic data: short-read files (ad-hoc generated depending on runtime)
\end{itemize}

\noindent
\textbf{Dynamic Scenarios:}
\begin{itemize}
	\item moving generated short-read data to available resources
	
	\item support processing of n experiments 

	\item re-partition of tasks to a larger number of available cores (dynamic data that needs to re-generated as a consequence that there are new compute elements available)

\end{itemize}

\section{BigJob API}
\label{sec:api}
\subsection{Resource Specification}


\begin{verbatim}
{
    "resource_url" : "pbspro://localhost/", 
    "number_nodes" : "2", 
    "processes_per_node":"4", 
    "allocation" : "loni_xyz", 
    "queue" : None, 
    "bigjob_agent": (BIGJOB_HOME + "/bigjob_agent_launcher.sh"), 
    "working_directory": (os.getcwd() + "/agent"), 
    "walltime":3600 
}
\end{verbatim}


\subsection{class: bigjob}


\begin{itemize}
	\item \_\_init\_\_
		\begin{itemize}
			\item database\_host
		\end{itemize}
	\item start\_pilot\_job
	\begin{itemize}
		\item lrms\_url
		\item bigjob\_agent\_executable
		\item number\_nodes
		\item queue
		\item project
		\item working\_directory
		\item userproxy
		\item walltime
		\item processes\_per\_node
	\end{itemize}
	\item get\_state	
	\item get\_state\_detail
	\item cancel
\end{itemize}

\subsection{class: subjob}
\begin{itemize}
\item \_\_init\_\_
		\begin{itemize}
			\item database\_host
		\end{itemize}
	\item submit\_job
	\begin{itemize}
		\item pilot\_url
		\item jd
	\end{itemize}

	\item get\_state

	\item delete\_job
\end{itemize}

\bibliographystyle{plain}
\bibliography{pilotjob}
\end{document}
